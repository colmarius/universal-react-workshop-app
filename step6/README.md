# Step 6

## Description
Add List SSR.

## How-to
- Add babel hook: npm i babel-register --save
- Create a `server/start.js` that register the hook:
``` javascript
require('babel-register')({
    presets: ['es2015', 'react'] // ...or use .babelrc
})
module.exports = require('.')
```
- Change the server start script to use the above in `package.json`:
``` json
    "server:dev": "node ./server/start"
```

- Change `TalkList` to support correct init.
- TODO:
  - Documentare il perchè del DIV aggiuntivo. Spiegare perchè serve il rendering.
    - (sperimentare se server davvero con la versione statica)
  - Evitare di usare le prop nell'inizializzazione (è OK passare per il global)
  - Qui Spiegato il perchè: https://github.com/reactjs/redux/blob/master/docs/recipes/ServerRendering.md
  - Agganciare il router
  - Ragionare sul proxy. 
``` javascript
proxy: {
  '**': 'http://localhost:4001'
}
```

## NOTE:
componentDidMount è chiamato solo sul client.
getInitialState è chiamato sia sul client che sul server.

Quindi:
- Il server produce il contunto renderizzato.
- Il client (react) verifica se deve ri-renderizzare il componente. quindi
  - riesegue tutto. Ri -renderizza se props & state sono diversi.
- componentDidMount non serve più: i dati dobbiamo già averli => li prendiamo da un global.
  (potremmo pure evitare di usare le props)
-

On lifecycle (generic)

  - componentWillMount is executed before rendering, on both server and client side.
  - componentDidMount is executed after first render only on the client side. This is where AJAX requests and DOM or state updates should occur.

    componentWillReceiveProps is invoked as soon as the props are updated before another render is called. We triggered it from setNewNumber when we updated the state.

    shouldComponentUpdate should return true or false value. This will determine if component will be updated or not. This is set to true by default. If you are sure that component doesn't need to render after state or props are updated, you can return false value.

    componentWillUpdate is called just before rendering.

    componentDidUpdate is called just after rendering.

    componentWillUnmount is called after the component is unmounted from the dom. We are unmounting our component in main.js.

What happens:

On the server, React appends a checksum for the rendered components to its outermost DOM node.
When a new component is passed to React on the client, it first checks for the existing HTML markup at the target DOM node and grabs the Adler-32 checksum appended by the server.
This value is compared to the checksum that would be generated by the provided React component and its props.
If the values are equivalent, no rendering is necessary, and thus no rendering is performed.

During server side render ComponentWillMount and render methods being fired up, but not ComponentDidMount
React's componentDidMount lifecycle hook is not called server-side, as stated in the docs.


TODO:

START FROM HERE: https://medium.com/@turadg/how-to-migrate-react-to-isomorphic-rendering-88347ba653a5#.7bdxojju1
https://medium.com/front-end-developers/handcrafting-an-isomorphic-redux-application-with-love-40ada4468af4#.ldiadaj7w

Set initialstate on components: http://stackoverflow.com/questions/27928296/reactjs-how-to-pass-the-initial-state-while-rendering-a-component

Additional DIV: http://stackoverflow.com/questions/33521047/warning-react-attempted-to-reuse-markup-in-a-container-but-the-checksum-was-inv
"Why does this work? On the client, React has a propensity to wrap its rendering of your root component with a superfluous div. ReactDOMServer.render doesn't seem to behave in this manner, thus when one renders into the same container isomorphically, the Adler-32 checksum of your DOM differs."

MA in tealtà il vero  problema è:
"if you are rendering your main content inside of a layout component, you will need to render the layout as static markup (no react attributes) so that the checksum of the content matches between the client and server."

Rehydration

So you’ve gathered all the data, rendered the page and sent it down to the client. Now you want the client-side to pick up where the server left off. You can simply begin executing the same Javascript on the client, and the page should render the same. However if the virtual DOM the client renders doesn’t exactly match the server’s, then the client has no idea what changed and can’t begin diff updates to it. Instead it will replace the whole thing, making a flicker and potentially scrapping important elements. React tests for sameness with a data-react-checksum on the root mounting element. For the test to pass, the first virtual DOM of the client to must match exactly the server’s that generated the HTML.

- Test https://medium.com/@firasd/quick-start-tutorial-universal-react-with-server-side-rendering-76fe5363d6e#.q9vofe2od
- https://github.com/firasd/react-server-tutorial
- E: https://medium.com/@MoBinni/a-modern-isomorphic-stack-6609c7c9d057#.3nzsurkb4
- E: https://github.com/ReactTraining/react-router/blob/master/docs/guides/ServerRendering.md
- Interessante su ciclo di vita in React
(quindi settiamo lo state)
- Rimuoviamo il proxy (check se serve ancora i contenuti statici).
Capire se c'è un altro modo...ma probabilmente no.
- Rimuoviamo il Router client-side (App.jsx) (?)


After set babel, you can try:
```
server.route({
  method: 'GET',
  path:'/api/talk-list',  //reouse same api route
  handler: (request, reply) => {
    console.log("************************")
    reply(renderToString(<App/>))
  }
})
```
...and change App.jsx to the one of step3. Reload, and see that it's rendering
ONLY that div. So templating is needed

Seguiamo: https://medium.com/@firasd/quick-start-tutorial-universal-react-with-server-side-rendering-76fe5363d6e#.q9vofe2od

Qui usa `hapi-react-view`: https://medium.com/@tribou/serving-react-and-flux-with-hapi-and-webpack-213afacf94ea#.1xxyhnko4


React aggiunge un checksum quando si usa `ReactDOM.renderToString` (e NON `renderToStaticMarkup`)
`<div class="container" id="container"><div class="talks" data-reactroot="" data-reactid="1" data-react-checksum="2068190256"></div></div>`

...per determinare se lun output dal server matcha con il client. Se NON matchano,
state/props su server e su client sono differenti.
