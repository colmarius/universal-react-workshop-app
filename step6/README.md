# Step 6

## Description
Add first page (list) SSR.

## How-to
- Add babel hook: npm i babel-register --save
- Create a `server/start.js` that register the hook:
``` javascript
require('babel-register')({
    presets: ['es2015', 'react'] // ...or use .babelrc
})
module.exports = require('.')
```
- Change the server start script to use the above in `package.json`:
``` json
    "server:dev": "node ./server/start"
```
- Change server, and add "page" renderer.  Add console.logs:
``` javascript
//(TODO)
```

- Change `TalkList` to support correct init in both cases
``` javascript
// (TODO)
```
- Proxy: we use a separate endpoint (so we can check the difference):
``` javascript
proxy: {
  '/api': 'http://localhost:4001',
  '/ssr': 'http://localhost:4001'
  }
```
-  Testare con un browser non-js: lynx http://127.0.0.1:4000/ssr
- CSS?

## NOTE:
- Documentare il perchè del DIV aggiuntivo. Spiegare perchè serve il rendering.
- Evitare di usare le prop nell'inizializzazione (è OK passare per il global)
- Qui Spiegato il perchè: https://github.com/reactjs/redux/blob/master/docs/recipes/ServerRendering.md
- Routing: NON SERVE! Noi mandiamo il componente renderizzato, poi React parte sul browser,
e non ri-renderizza la lista perchè già renderizzata

  componentDidMount è chiamato solo sul client.
  getInitialState è chiamato sia sul client che sul server.

Quindi:
- Il server produce il contunto renderizzato.
- Il client (react) verifica se deve ri-renderizzare il componente. quindi
  - riesegue tutto. Ri -renderizza se props & state sono diversi.
- componentDidMount non serve più: i dati dobbiamo già averli => li prendiamo da un global.
  (potremmo pure evitare di usare le props)
-

# FURTHER NOTES
## Lifecycle

  - componentWillMount is executed before rendering, on both server and client side.
  - componentDidMount is executed after first render only on the client side. This is where AJAX requests and DOM or state updates should occur.
  - componentWillReceiveProps is invoked as soon as the props are updated before another render is called. We triggered it from setNewNumber when we updated the state.
  - shouldComponentUpdate should return true or false value. This will determine if component will be updated or not. This is set to true by default. If you are sure that component doesn't need to render after state or props are updated, you can return false value.
  - componentWillUpdate is called just before rendering.
  - componentDidUpdate is called just after rendering.
  - componentWillUnmount is called after the component is unmounted from the dom. We are unmounting our component in main.js.

What happens:

## Checksum
On the server, React appends a checksum for the rendered components to its outermost DOM node.
When a new component is passed to React on the client, it first checks for the existing HTML markup at the target DOM node and grabs the Adler-32 checksum appended by the server.
This value is compared to the checksum that would be generated by the provided React component and its props.
If the values are equivalent, no rendering is necessary, and thus no rendering is performed.

During server side render ComponentWillMount and render methods being fired up, but not ComponentDidMount
React's componentDidMount lifecycle hook is not called server-side, as stated in the docs.


## Additional DIV
Additional DIV: http://stackoverflow.com/questions/33521047/warning-react-attempted-to-reuse-markup-in-a-container-but-the-checksum-was-inv
"Why does this work? On the client, React has a propensity to wrap its rendering of your root component with a superfluous div. ReactDOMServer.render doesn't seem to behave in this manner, thus when one renders into the same container isomorphically, the Adler-32 checksum of your DOM differs."

Ma in tealtà il vero  problema è:
"if you are rendering your main content inside of a layout component, you will need to render the layout as static markup (no react attributes) so that the checksum of the content matches between the client and server."

## Templating is needed

After set babel, you can try:
```
server.route({
  method: 'GET',
  path:'/api/talk-list',  //reouse same api route
  handler: (request, reply) => {
    console.log("************************")
    reply(renderToString(<App/>))
  }
})
```
...and change App.jsx to the one of step3. Reload, and see that it's rendering
ONLY that div. So templating is needed


## `renderToString` vs `renderToStaticMarkup`
React aggiunge un checksum quando si usa `ReactDOM.renderToString` (e NON `renderToStaticMarkup`)
`<div class="container" id="container"><div class="talks" data-reactroot="" data-reactid="1" data-react-checksum="2068190256"></div></div>`

...per determinare se l'output dal server matcha con il client. Se NON matchano,
state/props su server e su client sono differenti.


## WHY REACT CALLS RENDER ALSO ON CLIENT

Doesn't / couldn't React have enough info to go off of already, so as to not need an actual reference to the React component on the front-end as well?

No, it doesn’t. The DOM node is just the DOM: it does not contain any JavaScript code related to the component, such as event handlers or its render() method. The markup may arrive before the JS is even loaded, which is what makes server rendering useful.

Quindi l'HTML arriva SUBITO. React nemmeno è attivo, mancano i "markup" che servono
a React a rendere il codice dinamico.
In realtà lui chiama "render", ma non ri-renderizza. Se il markup è identico, attacca l'istanza
del componente al DOM. Se non coincide, allora il browser lo ri-renderizza..


## LINKS:
- https://medium.com/@firasd/quick-start-tutorial-universal-react-with-server-side-rendering-76fe5363d6e#.q9vofe2od
- https://github.com/firasd/react-server-tutorial
- https://medium.com/@MoBinni/a-modern-isomorphic-stack-6609c7c9d057#.3nzsurkb4
- https://github.com/ReactTraining/react-router/blob/master/docs/guides/ServerRendering.md
- https://medium.com/@firasd/quick-start-tutorial-universal-react-with-server-side-rendering-76fe5363d6e#.q9vofe2od
- https://medium.com/@tribou/serving-react-and-flux-with-hapi-and-webpack-213afacf94ea#.1xxyhnko4
- https://medium.com/@turadg/how-to-migrate-react-to-isomorphic-rendering-88347ba653a5#.7bdxojju1
- https://medium.com/front-end-developers/handcrafting-an-isomorphic-redux-application-with-love-40ada4468af4#.ldiadaj7w
